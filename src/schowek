Poly PolyAddMonos(size_t count, const Mono monos[]) {

    if (count == 0) return PolyZero();

    Poly p = {.size = count, .arr = calloc(count, sizeof(Mono))};
    CHECK_PTR(&p.arr);

//    Mono monosCopy[count];
//    CHECK_PTR(monosCopy);
//    for (size_t i = 0; i < count; ++i) {
//        monosCopy[i] = monos[i];
//    }
    SortMonos(count, monos);

    size_t index = 0;
    p.arr[0] = MonoClone(&monos[0]);
    for (size_t i = 1; i < count; i++) {
        if (monos[i - 1].exp == monos[i].exp) {
            Poly temp = p.arr[index].p;
            p.arr[index].p = PolyAdd(&monos[i].p, &temp);
            PolyDestroy(&temp);
        } else {
            if (isPolyZeroRec(&p.arr[index].p)) {
                MonoDestroy(&p.arr[index]);
            } else {
                index++;
            }
            p.arr[index] = MonoClone(&monos[i]);
        }
    }

//    for (size_t i = 0; i < count; ++i) {
//        MonoDestroy(&monosCopy[i]);
//    }

    if (isPolyZeroRec(&p)) {
        PolyDestroy(&p);
        return PolyZero();
    }

    if (isPolyCoeffRec(&p)) {
        poly_coeff_t coeff = getCoeff(&p);
        PolyDestroy(&p);
        return PolyFromCoeff(coeff);
    }

    if (index + 1 != count) {
        p.size = index + 1;
        p.arr = realloc(p.arr, p.size * sizeof(Mono));
        CHECK_PTR(&p.arr);
    }

    return p;
}

//////////////////////////////////


Poly PolyAddMonos(size_t count, const Mono monos[]) {

    if (count == 0) return PolyZero();

    Poly p = {.size = count, .arr = calloc(count, sizeof(Mono))};
    CHECK_PTR(&p.arr);

    Mono monosCopy[count];
    for (size_t i = 0; i < count; ++i) {
        monosCopy[i] = monos[i];
    }
    SortMonos(count, monosCopy);

    size_t index = 0;
    p.arr[0] = MonoClone(&monosCopy[0]);
    for (size_t i = 1; i < count; i++) {
        if (monosCopy[i - 1].exp == monosCopy[i].exp) {
            Poly temp = p.arr[index].p;
            p.arr[index].p = PolyAdd(&monosCopy[i].p, &temp);
            PolyDestroy(&temp);
        } else {
            if (isPolyZeroRec(&p.arr[index].p)) {
                MonoDestroy(&p.arr[index]);
            } else {
                index++;
            }
            p.arr[index] = MonoClone(&monosCopy[i]);
        }
    }

    for (size_t i = 0; i < count; ++i) {
        MonoDestroy(&monosCopy[i]);
    }

    if (isPolyZeroRec(&p)) {
        PolyDestroy(&p);
        return PolyZero();
    }

    if (isPolyCoeffRec(&p)) {
        poly_coeff_t coeff = getCoeff(&p);
        PolyDestroy(&p);
        return PolyFromCoeff(coeff);
    }

    if (index + 1 != count) {
        p.size = index + 1;
        p.arr = realloc(p.arr, p.size * sizeof(Mono));
        CHECK_PTR(&p.arr);
    }

    return p;
}

//////////


echo -e "${BLANK}TESTY Z VALGRINDEM (OBNIZONA DOKŁADNOSC):"


for f in "${FOLDER}"*.in
do
	NAME="${f%.in}"


    valgrind --error-exitcode=123 --leak-check=full --show-leak-kinds=all --errors-for-leak-kinds=all ./${PROG} <"$f" 1> "mine.out" 2> "mine.err"

	if diff  "mine.out" "${f%.in}.out"
    then
		echo -e "${GREEN}PLIK: $NAME - CORRECT OUT${BLANK}"
	else
		echo -e "${RED}PLIK: $NAME - INCORRECT OUT${BLANK}"
	fi

    if diff -q "mine.err" "${f%.in}.err"
    then
		echo -e "${GREEN}PLIK: $NAME - CORRECT ERR${BLANK}"
	else
		echo -e "${RED}PLIK: $NAME - INCORRECT ERR${BLANK}"
	fi

	rm "mine.out" "mine.err"
done